using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class Enemy_PokerHundJuge : MonoBehaviour
{
    [SerializeField] GameObject[] slots;
    [SerializeField, Header("プレイヤーの現在の絵柄")] public List<Sprite> _enemyCardSpriteNow = new List<Sprite>();
    [SerializeField, Header("プレイヤーのcardのrank")] public List<CardData.Rank> _enemyplayerRankJuge = new List<CardData.Rank>();
    [SerializeField, Header("プレイヤーのcardのsuit")] public List<CardData.Suit> _enemyplayerSuitJuge = new List<CardData.Suit>();

    [SerializeField, Header("スロットの絵柄")] public Sprite[] _slotSprite;
    [SerializeField, Header("スロットのrank")] public List<CardData.Rank> _slotRankJuge = new List<CardData.Rank>();
    [SerializeField, Header("スロットのsuit")] public List<CardData.Suit> _slotSuitJuge = new List<CardData.Suit>();
    [SerializeField, Header("判定するためのリスト")] public List<CardData> enemyCardDatas = CardManager._EnemyselectedCards;
    [SerializeField] public Text HundText;


    SlotStopSprite _slotStopSprite;
    Slot1 _slot1;


    private void Start()
    {
        //スロットがある分だけ配列を作る
        _slotSprite = new Sprite[slots.Length];
    }

    private void Update()
    {
        //各スロットのSlotStopSpriteを取得する
        for (int i = 0; i < slots.Length;)
        {
            _slotStopSprite = slots[i].GetComponent<SlotStopSprite>();
            _slotSprite[i] = _slotStopSprite._slotCardSpriteNow;
            i++;
        }

    }


    //役判定のメソッド
    public HandRank Enemy_GetHandRank()
    {
        //プレイヤーの持っているカードとスロットのカードをまとめる処理
        var cards = enemyCardDatas.Select(card => new { card.rank, card.suit }).ToList();

        //RoyalFlushか判定する処理
        bool RoyalFlush() => cards.Where(c => c.rank >= CardData.Rank.Ten && c.suit == cards[0].suit)
                                .OrderBy(c => (int)c.rank)
                                .Take(5)
                                .Select(c => (int)c.rank)
                                .SequenceEqual(Enumerable.Range(10, 5));

        bool StraitFlush() => cards.Where(c => c.suit == cards[0].suit
                                && (int)c.rank >= (int)cards.Min(x => (x.rank))
                                && (int)c.rank <= (int)cards.Min(x => (x.rank)) + 4)
                               .Count() >= 5;

        bool FullHouse() => cards.GroupBy(c => c.rank)
                           .Select(g => g.Count())
                           .OrderByDescending(x => x)
                           .Take(2)
                           .SequenceEqual(new[] { 3, 2 });

        bool Flush() => cards.GroupBy(g => g.suit).Any(g => g.Count() >= 5);

        bool Straight() => cards.Select(c => (int)c.rank)
                          .OrderBy(x => x)
                          .Distinct()
                          .Count(x => Enumerable.Range(x, 5).All(rank => cards.Any(c => (int)c.rank == rank))) >= 5;

        bool FourOfaKind() => cards.GroupBy(card => card.rank)
                            .Any(g => g.Count() >= 4);

        bool ThreeOfaKind() => cards.GroupBy(c => c.rank)
                              .Any(g => g.Count() >= 3);

        bool TowPair() => cards.GroupBy(c => c.rank)
                         .Select(g => g.Count())
                         .OrderByDescending(x => x)
                         .Take(2)
                         .SequenceEqual(new[] { 2, 2 });

        bool OnePair() => cards.GroupBy(c => c.rank)
                         .Any(g => g.Count() == 2);


        if (RoyalFlush())
        {
            return HandRank.RoyalFlush;
        }
        else if (StraitFlush())
        {
            return HandRank.StraightFlush;
        }
        else if (FourOfaKind())
        {
            return HandRank.FourOfAKind;
        }
        else if (FullHouse())
        {
            return HandRank.FullHouse;
        }
        else if (Flush())
        {
            return HandRank.Flush;
        }
        else if (Straight())
        {
            return HandRank.Straight;
        }
        else if (ThreeOfaKind())
        {
            return HandRank.ThreeOfAKind;
        }
        else if (TowPair())
        {
            return HandRank.TwoPair;
        }
        else if (OnePair())
        {
            return HandRank.OnePair;
        }
        else
        {
            return HandRank.HighCard;
        }
    }

    public void Enemy_HandCheck()
    {


        HandRank rank = Enemy_GetHandRank();
        switch (rank)
        {
            case HandRank.RoyalFlush:
                HundText.text = "ロイヤルストレートフラッシュ";
                break;
            case HandRank.StraightFlush:
                HundText.text = ("ストレートフラッシュ");
                break;
            case HandRank.FourOfAKind:
                HundText.text = ("フォーカード");
                break;
            case HandRank.FullHouse:
                HundText.text = ("フルハウス");
                break;
            case HandRank.Flush:
                HundText.text = ("フラッシュ");
                break;
            case HandRank.Straight:
                HundText.text = ("ストレート");
                break;
            case HandRank.ThreeOfAKind:
                HundText.text = ("スリーカード");
                break;
            case HandRank.TwoPair:
                HundText.text = ("ツーペア");
                break;
            case HandRank.OnePair:
                HundText.text = ("ワンペア");
                break;
            default:
                HundText.text = ("ハイカード");
                break;
        }
    }


    public void RemoveListsJage()
    {
        _enemyCardSpriteNow.Clear();
        _enemyplayerRankJuge.Clear();
        _enemyplayerSuitJuge.Clear();
        _slotRankJuge.Clear();
        _slotSuitJuge.Clear();
        enemyCardDatas.Clear();
    }


    public enum HandRank : int
    {
        RoyalFlush = 10,
        StraightFlush = 9,
        FourOfAKind = 8,
        FullHouse = 7,
        Flush = 6,
        Straight = 5,
        ThreeOfAKind = 4,
        TwoPair = 3,
        OnePair = 2,
        HighCard = 1
    }


}
